<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LedFlow v2.0</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Homemade+Apple&family=Lato&family=Merriweather&family=Raleway&family=Source+Sans+Pro&family=VT323&family=Micro+5&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: row;
            margin: 0;
            height: 100vh;
            background: #252526;
            color: #ffffff;
            box-sizing: border-box;
        }
        .main-content {
            display: flex;
            flex: 1;
            flex-direction: row;
            overflow: hidden;
            position: relative;
        }
        .left-panel {
            width: 20%;
            display: flex;
            flex-direction: column;
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
            position: relative;
            padding-bottom: 60px;
        }
        .left-panel.collapsed {
            width: 0;
            display: none;
        }
        .right-panel {
            width: calc(80% - 40px);
            display: flex;
            flex-direction: column;
            padding: 10px;
            box-sizing: border-box;
            height: 100%;
            margin-left: 40px;
        }
        .right-panel.collapsed {
            width: calc(100% - 50px);
        }
        .collapse-button {
            width: 30px;
            height: 30px;
            background: linear-gradient(to right, #666, #0056b3);
            color: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            position: absolute;
            top: 10px;
            left: 20%;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s;
        }
        .collapse-button.collapsed {
            left: 0;
        }
        .collapse-button:hover {
            background: linear-gradient(to right, #777, #003d80);
        }
        .collapse-button::before {
            content: '<';
            font-size: 16px;
        }
        .collapse-button.collapsed::before {
            content: '>';
        }
        .row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }
        .compact-row {
            display: flex;
            align-items: flex-start;
            margin-bottom: 10px;
            gap: 5px;
            flex-wrap: wrap;
        }
        .row label {
            width: 90px;
            color: #ffffff;
            font-size: 12px;
        }
        .compact-row label {
            width: 60px;
            color: #ffffff;
            font-size: 12px;
            line-height: 1.2;
        }
        .color-group label {
            flex: 0 0 auto;
            width: auto;
            color: #ffffff;
            font-size: 12px;
        }
        .row input[type="number"] {
            padding: 5px;
            width: 60px;
            background-color: #333;
            color: #ffffff;
            border: 1px solid #555;
            font-family: Arial, sans-serif;
        }
        .row select.color-select {
            width: 100px;
            height: 30px;
            padding: 5px;
            background-color: #333;
            color: #ffffff;
            border: 1px solid #555;
            font-family: Arial, sans-serif;
            cursor: pointer;
        }
        .row select.color-select option {
            background-color: #333;
            color: #ffffff;
            padding: 5px;
        }
        .row select.color-select option::before {
            content: "в–  ";
            font-size: 16px;
        }
        .row input[type="range"], .compact-row input[type="range"] {
            width: 100px;
            cursor: pointer;
        }
        .compact-row input[type="range"] {
            font-size: 12px;
        }
        .row select:not(.color-select) {
            padding: 5px;
            width: 130px;
            background-color: #333;
            color: #ffffff;
            border: 1px solid #555;
            font-family: Arial, sans-serif;
            cursor: pointer;
        }
        button {
            width: 50px;
            padding: 8px;
            cursor: pointer;
            background: linear-gradient(to right, #666, #0056b3);
            color: #ffffff;
            border: none;
            border-radius: 4px;
            text-align: center;
            font-family: Arial, sans-serif;
            transition: background 0.3s;
        }
        button:hover {
            background: linear-gradient(to right, #777, #003d80);
        }
        #canvasContainer {
            flex: 1;
            overflow: auto;
            position: relative;
        }
        canvas {
            background-color: transparent;
            display: block;
            position: absolute;
            top: 0;
            left: 40px;
            transform-origin: top left;
        }
        canvas.collapsed {
            left: 20px;
        }
        #linesList, #groupsList {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            width: 80%;
            margin-left: 40px;
        }
        .line-item {
            display: grid;
            grid-template-columns: 30px auto 40px 40px 24px;
            align-items: center;
            padding: 5px;
            gap: 5px;
            color: #ffffff;
            font-family: Arial, sans-serif;
            font-size: 12px;
        }
        .line-item input[type="text"] {
            padding: 5px;
            width: 40px;
            background-color: #333;
            color: #ffffff;
            border: 1px solid #555;
            font-family: Arial, sans-serif;
            font-size: 9px;
        }
        .group-item {
            display: grid;
            grid-template-columns: 30px auto 40px 24px;
            align-items: center;
            padding: 5px;
            gap: 5px;
            color: #ffffff;
            font-family: Arial, sans-serif;
            font-size: 12px;
        }
        .group-item input[type="number"] {
            padding: 5px;
            width: 40px;
            background-color: #333;
            color: #ffffff;
            border: 1px solid #555;
            font-family: Arial, sans-serif;
            font-size: 9px;
        }
        .line-item button, .group-item button {
            padding: 3px;
            background-color: #ff4444;
            width: 24px;
            text-align: center;
            font-family: Arial, sans-serif;
            font-size: 12px;
        }
        .line-item button:hover, .group-item button:hover {
            background-color: #cc0000;
        }
        .line-item button:disabled, .group-item button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        .default-names-checkbox {
            display: flex;
            align-items: center;
            margin-top: 10px;
            margin-left: 0;
        }
        .default-names-checkbox input[type="checkbox"] {
            margin-right: 5px;
            transform: scale(1.2);
        }
        .default-names-checkbox label {
            font-size: 10px;
            margin: 0;
        }
        .note {
            font-family: Arial, sans-serif;
            font-size: 12px;
            color: #cccccc;
            margin-top: 10px;
            margin-left: 10px;
            line-height: 1.4;
        }
        .summary {
            font-family: Arial, sans-serif;
            font-size: 12px;
            color: #cccccc;
            margin-top: 10px;
            margin-left: 10px;
            line-height: 1.4;
        }
        .signature {
            font-family: Arial, sans-serif;
            font-size: 12px;
            font-weight: bold;
            font-style: italic;
            color: #cccccc;
            margin-top: 5px;
            margin-left: 10px;
            position: absolute;
            bottom: 10px;
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            width: 130px;
        }
        #customSizeInputs {
            display: none;
        }
        .color-group {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        #xmlImport {
            display: none;
        }
        .label-slider-pair {
            display: flex;
            align-items: flex-start;
            gap: 5px;
        }
        .tab-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        .tab-button {
            padding: 10px 24px;
            background-color: #333;
            color: #ffffff;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 16px;
            text-align: center;
            min-width: 100px;
        }
        .tab-button.active {
            background-color: #0056b3;
            border-color: #ffffff;
        }
        .tab-button:hover {
            background-color: #444;
        }
        .tab-content {
            display: none;
            position: relative;
            flex: 1;
        }
        .tab-content.active {
            display: block;
        }
        @media (max-width: 768px) {
            #linesList, #groupsList {
                width: 75%;
                margin-left: 30px;
            }
            .default-names-checkbox {
                margin-left: 0;
            }
            .note, .summary, .signature {
                font-size: 10px;
                margin-left: 5px;
            }
            .tab-button {
                padding: 8px 16px;
                font-size: 14px;
                min-width: 80px;
            }
            .collapse-button {
                width: 24px;
                height: 24px;
            }
            .collapse-button::before {
                font-size: 14px;
            }
            .right-panel {
                margin-left: 30px;
            }
            .right-panel.collapsed {
                width: calc(100% - 44px);
            }
            canvas {
                left: 30px;
            }
            canvas.collapsed {
                left: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="main-content">
        <div class="left-panel">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab('settings')">Settings</button>
                <button class="tab-button" onclick="switchTab('data')">Data</button>
                <button class="tab-button" onclick="switchTab('power')">Power</button>
            </div>
            <div id="settings-tab" class="tab-content active">
                <div class="row">
                    <label>col x rows</label>
                    <div class="input-group">
                        <input type="number" id="cols" min="1" value="16">
                        <span>x</span>
                        <input type="number" id="rows" min="1" value="9">
                    </div>
                </div>
                <div class="row">
                    <label>module size</label>
                    <select id="moduleSize" onchange="handleModuleSizeChange()">
                        <option value="84">84px</option>
                        <option value="104" selected>104px</option>
                        <option value="128">128px</option>
                        <option value="192">192px</option>
                        <option value="256">256px</option>
                        <option value="custom">custom</option>
                    </select>
                </div>
                <div class="row" id="customSizeInputs">
                    <label></label>
                    <div class="input-group">
                        <input type="number" id="moduleWidth" min="10" value="104">
                        <span>x</span>
                        <input type="number" id="moduleHeight" min="10" value="104">
                    </div>
                </div>
                <div class="row">
                    <div class="color-group">
                        <label for="moduleColor">fill color:</label>
                        <select id="moduleColor" class="color-select">
                            <option value="#0A0A0A" style="background-color: #0A0A0A;">Coal</option>
                            <option value="#141414" style="background-color: #141414;">Raven</option>
                            <option value="#1E1E1E" style="background-color: #1E1E1E;">Anthracite</option>
                            <option value="#282828" style="background-color: #282828;">Graphite</option>
                            <option value="#323232" style="background-color: #323232;">Lead</option>
                            <option value="#3C3C3C" style="background-color: #3C3C3C;">Asphalt</option>
                            <option value="#464646" style="background-color: #464646;">Slate</option>
                            <option value="#505050" style="background-color: #505050;">Iron</option>
                            <option value="#5A5A5A" style="background-color: #5A5A5A;">Steel</option>
                            <option value="#646464" style="background-color: #646464;">Smoke</option>
                            <option value="#6E6E6E" style="background-color: #6E6E6E;">Mouse</option>
                            <option value="#787878" style="background-color: #787878;">Stone</option>
                            <option value="#828282" style="background-color: #828282;">Neutral</option>
                            <option value="#8C8C8C" style="background-color: #8C8C8C;">Cement</option>
                            <option value="#969696" style="background-color: #969696;" selected>Ash</option>
                            <option value="#A0A0A0" style="background-color: #A0A0A0;">Concrete</option>
                            <option value="#AAAAAA" style="background-color: #AAAAAA;">Silver</option>
                            <option value="#B4B4B4" style="background-color: #B4B4B4;">Mist</option>
                            <option value="#BEBEBE" style="background-color: #BEBEBE;">Pale Gray</option>
                            <option value="#C8C8C8" style="background-color: #C8C8C8;">Fog</option>
                            <option value="#D2D2D2" style="background-color: #D2D2D2;">Pearl</option>
                            <option value="#DCDCDC" style="background-color: #DCDCDC;">Gainsboro</option>
                            <option value="#E6E6E6" style="background-color: #E6E6E6;">Platinum</option>
                            <option value="#F0F0F0" style="background-color: #F0F0F0;">Moon</option>
                            <option value="#FAFAFA" style="background-color: #FAFAFA;">Snow</option>
                        </select>
                        <label for="moduleLabelColor">label color:</label>
                        <select id="moduleLabelColor" class="color-select">
                            <option value="#0A0A0A" style="background-color: #0A0A0A;">Coal</option>
                            <option value="#141414" style="background-color: #141414;">Raven</option>
                            <option value="#1E1E1E" style="background-color: #1E1E1E;">Anthracite</option>
                            <option value="#282828" style="background-color: #282828;">Graphite</option>
                            <option value="#323232" style="background-color: #323232;" selected>Lead</option>
                            <option value="#3C3C3C" style="background-color: #3C3C3C;">Asphalt</option>
                            <option value="#464646" style="background-color: #464646;">Slate</option>
                            <option value="#505050" style="background-color: #505050;">Iron</option>
                            <option value="#5A5A5A" style="background-color: #5A5A5A;">Steel</option>
                            <option value="#646464" style="background-color: #646464;">Smoke</option>
                            <option value="#6E6E6E" style="background-color: #6E6E6E;">Mouse</option>
                            <option value="#787878" style="background-color: #787878;">Stone</option>
                            <option value="#828282" style="background-color: #828282;">Neutral</option>
                            <option value="#8C8C8C" style="background-color: #8C8C8C;">Cement</option>
                            <option value="#969696" style="background-color: #969696;">Ash</option>
                            <option value="#A0A0A0" style="background-color: #A0A0A0;">Concrete</option>
                            <option value="#AAAAAA" style="background-color: #AAAAAA;">Silver</option>
                            <option value="#B4B4B4" style="background-color: #B4B4B4;">Mist</option>
                            <option value="#BEBEBE" style="background-color: #BEBEBE;">Pale Gray</option>
                            <option value="#C8C8C8" style="background-color: #C8C8C8;">Fog</option>
                            <option value="#D2D2D2" style="background-color: #D2D2D2;">Pearl</option>
                            <option value="#DCDCDC" style="background-color: #DCDCDC;">Gainsboro</option>
                            <option value="#E6E6E6" style="background-color: #E6E6E6;">Platinum</option>
                            <option value="#F0F0F0" style="background-color: #F0F0F0;">Moon</option>
                            <option value="#FAFAFA" style="background-color: #FAFAFA;">Snow</option>
                        </select>
                    </div>
                </div>
                <div class="compact-row">
                    <div class="label-slider-pair">
                        <label for="moduleLabelFontSize">label<br>size:</label>
                        <input type="range" id="moduleLabelFontSize" min="10" max="100" step="1" value="25">
                    </div>
                    <div class="label-slider-pair">
                        <label for="hatchDensity">hatch<br>density:</label>
                        <input type="range" id="hatchDensity" min="2" max="18" step="1" value="10">
                    </div>
                </div>
               <div class="row">
                    <button onclick="generateGrid()" title="generate">⚙</button>
                    <button onclick="resetGrid()" title="reset">↺</button>
                    <button onclick="zoomOut()" title="zoom out">-</button>
                    <button onclick="zoomIn()" title="zoom in">+</button>
                </div>
                <div class="row">
                    <button onclick="exportToXML()" title="export XML">XML ↓</button>
                    <button onclick="document.getElementById('xmlImport').click()" title="import XML">XML ↑</button>
                    <button onclick="exportToPNG()" title="export PNG">PNG ↓</button>
                    <button onclick="exportToSVG()" title="export SVG">SVG ↓</button>
                </div>
                <input type="file" id="xmlImport" accept=".xml" onchange="importFromXML(event)">
                <div class="note">
<br>
<br>
<br>
<br>
<br>
                    click to add LED cabinets to Data Line, double-click to complete selection<br>
<br>
                    ALT + click to add LED cabinets to Power Line, ALT + double-click to complete selection<br>
<br>
                    CTRL + click to toggle cabinet visibility (+ removes LED cabinet from Data/Power Line)<br>
<br>
                    SHIFT + click to start visibility batch selection,<br>
					second SHIFT + click to complete and hide LED cabinets
                </div>
            </div>
            <div id="data-tab" class="tab-content">
                <div id="linesList"></div>
                <div class="default-names-checkbox">
                    <input type="checkbox" id="useDefaultNames" checked onchange="handleDefaultNamesChange()">
                    <label for="useDefaultNames">Use default names</label>
                </div>
                <div class="default-names-checkbox">
                    <label for="connectionFont">Data Line font:</label>
                    <select id="connectionFont" style="font-size: 13px; padding: 2px;" onchange="drawGrid()">
                        <option value="Homemade Apple, cursive" style="font-size: 13px;">Homemade Apple</option>
                        <option value="Lato, sans-serif" style="font-size: 13px;">Lato</option>
                        <option value="Merriweather, serif" style="font-size: 13px;" selected>Merriweather</option>
                        <option value="Raleway, sans-serif" style="font-size: 13px;">Raleway</option>
                        <option value="Source Sans Pro, sans-serif" style="font-size: 13px;">Source Sans Pro</option>
                        <option value="VT323, monospace" style="font-size: 13px;">VT323</option>
                    </select>
                </div>
                <div class="default-names-checkbox">
                    <label for="connectionFontSize">font size:</label>
                    <input type="range" id="connectionFontSize" min="30" max="100" step="1" value="21" style="width: 100px;" oninput="drawGrid()">
                </div>
            </div>
            <div id="power-tab" class="tab-content">
                <div id="groupsList"></div>
            </div>
            <div class="summary" id="summary">
                total data lines: 0 with avg. 0 (0 to 0) cabinets per line<br>
                total power lines: 0 with avg. 0 (0 to 0) cabinets per line<br>
                total not connected cabinets: 0
            </div>
            <div class="signature">LedFlow v2.0 by Danny A. @ Blackout Minsk</div>
        </div>
        <div class="collapse-button" id="collapseButton" onclick="toggleLeftPanel()"></div>
        <div class="right-panel">
            <div id="canvasContainer">
                <canvas id="gridCanvas"></canvas>
            </div>
        </div>
    </div>

    <script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
            return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
            if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
                try {
                    var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                    var firstSheetName = workbook.SheetNames[0];
                    var worksheet = workbook.Sheets[firstSheetName];
                    var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                    var filteredData = jsonData.filter(row => row.some(filledCell));
                    var headerRowIndex = filteredData.findIndex((row, index) =>
                        row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                    );
                    if (headerRowIndex === -1 || headerRowIndex > 25) {
                        headerRowIndex = 0;
                    }
                    var csv = XLSX.utils.sheet_to_csv(XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)), { header: 1 });
                    return csv;
                } catch (e) {
                    console.error(e);
                    return "";
                }
            }
            return gk_fileData[filename] || "";
        }

        function toggleLeftPanel(collapse = null) {
            const leftPanel = document.querySelector('.left-panel');
            const rightPanel = document.querySelector('.right-panel');
            const collapseButton = document.getElementById('collapseButton');
            const canvas = document.getElementById('gridCanvas');
            const isCollapsed = collapse !== null ? collapse : leftPanel.classList.contains('collapsed');
            if (collapse === true || (collapse === null && !isCollapsed)) {
                leftPanel.classList.add('collapsed');
                rightPanel.classList.add('collapsed');
                collapseButton.classList.add('collapsed');
                canvas.classList.add('collapsed');
            } else {
                leftPanel.classList.remove('collapsed');
                rightPanel.classList.remove('collapsed');
                collapseButton.classList.remove('collapsed');
                canvas.classList.remove('collapsed');
            }
            updateScrollbars();
        }
    </script>
    <script>
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvasContainer');
        const linesList = document.getElementById('linesList');
        const groupsList = document.getElementById('groupsList');
        let gridState = [];
        let connections = [];
        let currentConnection = [];
        let currentColor = null;
        let selectedModules = [];
        let selectedGroups = [];
        let lineCounter = 1;
        let groupCounter = 1;
        let removedIndices = [];
        let removedGroupIndices = [];
        let currentScale = 0.60;
        let visibilityStart = null;
        let blinkInterval = null;
        let lastPresetSize = 104;
        const scales = [0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00];
        const mainColors = [
            '#FF0000', '#006400', '#0000FF', '#FFA500', '#FF00FF', '#00FFFF',
            '#FFFF00', '#800080', '#008000', '#000080', '#800000', '#FF4500',
            '#00FF00', '#FFD700', '#4B0082', '#00CED1'
        ];
        const groupColors = [
            '#0A0A0A', '#141414', '#1E1E1E', '#282828', '#323232',
            '#3C3C3C', '#464646', '#505050', '#5A5A5A', '#646464',
            '#6E6E6E', '#787878', '#828282', '#8C8C8C', '#969696',
            '#A0A0A0', '#AAAAAA', '#B4B4B4', '#BEBEBE', '#C8C8C8',
            '#D2D2D2', '#DCDCDC', '#E6E6E6', '#F0F0F0', '#FAFAFA'
        ];

        function initializeGrid(cols, rows) {
            gridState = Array(rows).fill().map(() => Array(cols).fill(true));
            connections = [];
            currentConnection = [];
            currentColor = null;
            selectedModules = [];
            selectedGroups = [];
            lineCounter = 1;
            groupCounter = 1;
            removedIndices = [];
            removedGroupIndices = [];
            updateLinesList();
            updateGroupsList();
            updateSummary();
            updateFontSizeSliders();
        }

        function resetGrid() {
            const { cols, rows } = getGridParams();
            gridState = Array(rows).fill().map(() => Array(cols).fill(true));
            connections = [];
            currentConnection = [];
            currentColor = null;
            selectedModules = [];
            selectedGroups = [];
            lineCounter = 1;
            groupCounter = 1;
            removedIndices = [];
            removedGroupIndices = [];
            if (blinkInterval) {
                clearInterval(blinkInterval);
                blinkInterval = null;
                visibilityStart = null;
            }
            updateLinesList();
            updateGroupsList();
            drawGrid();
            updateSummary();
        }

        function handleModuleSizeChange() {
            const moduleSizeSelect = document.getElementById('moduleSize');
            const customSizeInputs = document.getElementById('customSizeInputs');
            const moduleWidthInput = document.getElementById('moduleWidth');
            const moduleHeightInput = document.getElementById('moduleHeight');
            const size = moduleSizeSelect.value;

            if (size !== 'custom') {
                lastPresetSize = parseInt(size);
                customSizeInputs.style.display = 'none';
            } else {
                customSizeInputs.style.display = 'flex';
                moduleWidthInput.value = lastPresetSize;
                moduleHeightInput.value = lastPresetSize;
            }
            generateGrid();
        }

        function updateSummary() {
            const summaryDiv = document.getElementById('summary');
            const A = connections.length;
            const dataLineCounts = connections.map(conn => conn.points.length).filter(count => count >= 2);
            const B = A > 0 ? Math.round(dataLineCounts.reduce((sum, count) => sum + count, 0) / A) : 0;
            const C = A > 0 ? Math.min(...dataLineCounts) : 0;
            const D = A > 0 ? Math.max(...dataLineCounts) : 0;
            const E = selectedGroups.length;
            const powerLineCounts = selectedGroups.map(group => group.modules.length).filter(count => count > 0);
            const F = E > 0 ? Math.round(powerLineCounts.reduce((sum, count) => sum + count, 0) / E) : 0;
            const G = E > 0 ? Math.min(...powerLineCounts) : 0;
            const H = E > 0 ? Math.max(...powerLineCounts) : 0;
            let K = 0;
            for (let row = 0; row < gridState.length; row++) {
                for (let col = 0; col < gridState[0].length; col++) {
                    if (gridState[row][col]) {
                        const inDataLine = connections.some(conn => conn.points.some(p => p.row === row && p.col === col));
                        const inPowerLine = selectedGroups.some(group => group.modules.some(m => m.row === row && m.col === col));
                        if (!(inDataLine && inPowerLine)) {
                            K++;
                        }
                    }
                }
            }
            summaryDiv.innerHTML = `
                total data lines: ${A} with avg. ${B} (${C} to ${D}) cabinets per line<br>
                total power lines: ${E} with avg. ${F} (${G} to ${H}) cabinets per line<br>
                total not connected cabinets: ${K}
            `;
        }

        function updateFontSizeSliders() {
            const moduleSize = document.getElementById('moduleSize').value;
            const moduleHeight = moduleSize === 'custom' ? parseInt(document.getElementById('moduleHeight').value) : parseInt(moduleSize);
            document.getElementById('moduleLabelFontSize').value = Math.round(0.2 * moduleHeight);
            document.getElementById('moduleColor').value = '#969696';
            document.getElementById('moduleLabelColor').value = '#323232';
            document.getElementById('hatchDensity').value = 10;
        }

        let activeTab = 'settings';

        function switchTab(tab) {
            activeTab = tab;
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
                if (button.textContent.toLowerCase() === tab) {
                    button.classList.add('active');
                }
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
                if (content.id === `${tab}-tab`) {
                    content.classList.add('active');
                }
            });
            drawGrid();
        }

        function getGridParams() {
            const moduleSize = document.getElementById('moduleSize').value;
            const moduleWidth = moduleSize === 'custom' ? parseInt(document.getElementById('moduleWidth').value) : parseInt(moduleSize);
            const moduleHeight = moduleSize === 'custom' ? parseInt(document.getElementById('moduleHeight').value) : parseInt(moduleSize);
            return {
                cols: parseInt(document.getElementById('cols').value),
                rows: parseInt(document.getElementById('rows').value),
                moduleWidth: moduleWidth,
                moduleHeight: moduleHeight,
                moduleColor: document.getElementById('moduleColor').value,
                moduleLabelColor: document.getElementById('moduleLabelColor').value
            };
        }

        function updateScrollbars() {
            const containerRect = canvasContainer.getBoundingClientRect();
            const scaledWidth = canvas.width * currentScale;
            const scaledHeight = canvas.height * currentScale;
            const canvasOffsetLeft = document.querySelector('.left-panel').classList.contains('collapsed') ? 20 : 40;

            canvasContainer.scrollLeft = 0;
            canvasContainer.scrollTop = 0;

            if (scaledWidth + canvasOffsetLeft > containerRect.width || scaledHeight > containerRect.height) {
                canvasContainer.style.overflow = 'auto';
            } else {
                canvasContainer.style.overflow = 'hidden';
            }
        }

        function generateGrid() {
            const { cols: newCols, rows: newRows, moduleWidth, moduleHeight } = getGridParams();
            const oldGridState = gridState;
            const oldRows = oldGridState.length;
            const oldCols = oldRows > 0 ? oldGridState[0].length : 0;
            const newGridState = Array(newRows).fill().map(() => Array(newCols).fill(true));

            for (let r = 0; r < Math.min(oldRows, newRows); r++) {
                for (let c = 0; c < Math.min(oldCols, newCols); c++) {
                    newGridState[r][c] = oldGridState[r][c];
                }
            }

            gridState = newGridState;
            connections = connections.map(conn => ({
                ...conn,
                points: conn.points.filter(p => p.row < newRows && p.col < newCols && p.row >= 0 && p.col >= 0)
            })).filter(conn => conn.points.length >= 2);
            selectedGroups = selectedGroups.map(group => ({
                ...group,
                modules: group.modules.filter(m => m.row < newRows && m.col < newCols && m.row >= 0 && m.col >= 0)
            })).filter(group => group.modules.length > 0);

            lineCounter = connections.length + 1;
            groupCounter = selectedGroups.length + 1;

            canvas.width = newCols * moduleWidth;
            canvas.height = newRows * moduleHeight;
            canvas.style.transform = `scale(${currentScale})`;

            drawGrid();
            updateLinesList();
            updateGroupsList();
            updateSummary();
            updateScrollbars();
        }

        function zoomOut() {
            let currentIndex = scales.indexOf(currentScale);
            currentScale = currentIndex === -1
                ? scales.reduce((prev, curr) => curr < currentScale && (!prev || curr > prev) ? curr : prev, scales[0])
                : scales[Math.max(currentIndex - 1, 0)];
            canvas.style.transform = `scale(${currentScale})`;
            drawGrid();
            updateScrollbars();
        }

        function zoomIn() {
            let currentIndex = scales.indexOf(currentScale);
            currentScale = currentIndex === -1
                ? scales.reduce((prev, curr) => curr > currentScale && (!prev || curr < prev) ? curr : prev, scales[scales.length - 1])
                : scales[Math.min(currentIndex + 1, scales.length - 1)];
            canvas.style.transform = `scale(${currentScale})`;
            drawGrid();
            updateScrollbars();
        }

        window.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowDown') {
                event.preventDefault();
                zoomOut();
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                zoomIn();
            } else if (event.key === 'ArrowLeft') {
                event.preventDefault();
                toggleLeftPanel(true);
            } else if (event.key === 'ArrowRight') {
                event.preventDefault();
                toggleLeftPanel(false);
            }
        });

        async function drawGrid() {
            await document.fonts.ready;
            const { cols, rows, moduleWidth, moduleHeight, moduleColor, moduleLabelColor } = getGridParams();
            const labelFontSize = parseInt(document.getElementById('moduleLabelFontSize').value);
            const connectionFontSize = parseInt(document.getElementById('connectionFontSize').value);
            const connectionFont = document.getElementById('connectionFont').value;

            await document.fonts.load(`bold ${connectionFontSize}px ${connectionFont}`);
            await document.fonts.load(`${labelFontSize}px Arial, sans-serif`);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.lineWidth = 1;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (gridState[row][col]) {
                        const x = col * moduleWidth;
                        const y = row * moduleHeight;
                        ctx.fillStyle = moduleColor;
                        ctx.fillRect(x, y, moduleWidth, moduleHeight);
                        ctx.strokeStyle = moduleLabelColor;
                        ctx.strokeRect(x, y, moduleWidth, moduleHeight);

                        ctx.save();
                        ctx.font = `${labelFontSize}px Arial, sans-serif`;
                        ctx.fillStyle = moduleLabelColor;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        ctx.fillText(`${row + 1}.${col + 1}`, x + 10, y + 10);
                        ctx.restore();
                    }
                }
            }

            connections.forEach((conn, index) => {
                drawMainSelection(conn.points, conn.color, moduleWidth, moduleHeight, index % 2 === 0);
            });

            if (currentConnection.length > 0) {
                const isForwardSlash = (removedIndices[0] || connections.length) % 2 === 0;
                drawMainSelection(currentConnection, currentColor, moduleWidth, moduleHeight, isForwardSlash);
            }

            selectedModules.forEach(module => {
                const x = module.col * moduleWidth;
                const y = module.row * moduleHeight;
                ctx.save();
                ctx.strokeStyle = '#5A5A5A';
                ctx.lineWidth = 9;
                ctx.setLineDash([22.5, 10]);
                ctx.strokeRect(x + 4.5, y + 4.5, moduleWidth - 9, moduleHeight - 9);
                ctx.setLineDash([]);
                ctx.restore();
            });

            selectedGroups.forEach((group, index) => {
                if (group.modules.length > 0) {
                    const edges = [];
                    const offset = 4.5;
                    group.modules.forEach(module => {
                        const x = module.col * moduleWidth;
                        const y = module.row * moduleHeight;
                        if (!group.modules.some(p => p.row === module.row - 1 && p.col === module.col)) {
                            edges.push({ x1: x + offset, y1: y + offset, x2: x + moduleWidth - offset, y2: y + offset });
                        }
                        if (!group.modules.some(p => p.row === module.row + 1 && p.col === module.col)) {
                            edges.push({ x1: x + offset, y1: y + moduleHeight - offset, x2: x + moduleWidth - offset, y2: y + moduleHeight - offset });
                        }
                        if (!group.modules.some(p => p.row === module.row && p.col === module.col - 1)) {
                            edges.push({ x1: x + offset, y1: y + offset, x2: x + offset, y2: y + moduleHeight - offset });
                        }
                        if (!group.modules.some(p => p.row === module.row && p.col === module.col + 1)) {
                            edges.push({ x1: x + moduleWidth - offset, y1: y + offset, x2: x + moduleWidth - offset, y2: y + moduleHeight - offset });
                        }
                    });
                    ctx.save();
                    ctx.strokeStyle = groupColors[group.colorIndex - 1];
                    ctx.lineWidth = 9;
                    ctx.setLineDash([22.5, 10]);
                    ctx.beginPath();
                    edges.forEach(edge => {
                        ctx.moveTo(edge.x1, edge.y1);
                        ctx.lineTo(edge.x2, edge.y2);
                    });
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }
            });

            ctx.save();
            ctx.globalAlpha = 1;
            connections.forEach(conn => {
                if (conn.name && conn.points.length > 0) {
                    const first = conn.points[0];
                    let labelX = first.col * moduleWidth + moduleWidth / 2;
                    let labelY = first.row * moduleHeight + moduleHeight / 2;
                    if (conn.points.length > 1) {
                        const second = conn.points[1];
                        if (second.col > first.col) {
                            labelX = first.col * moduleWidth + moduleWidth / 4;
                            labelY = first.row * moduleHeight + 3 * moduleHeight / 4;
                        } else if (second.col < first.col) {
                            labelX = first.col * moduleWidth + 3 * moduleWidth / 4;
                            labelY = first.row * moduleHeight + moduleHeight / 4;
                        } else if (second.row > first.row) {
                            labelX = first.col * moduleWidth + 3 * moduleWidth / 4;
                            labelY = first.row * moduleHeight + moduleHeight / 4;
                        } else if (second.row < first.row) {
                            labelX = first.col * moduleWidth + moduleWidth / 4;
                            labelY = first.row * moduleHeight + 3 * moduleHeight / 4;
                        }
                    }
                    ctx.font = `bold ${connectionFontSize}px ${connectionFont}`;
                    ctx.fillStyle = '#000000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(conn.name, labelX, labelY);
                }
                if (conn.endName && conn.points.length > 0) {
                    const last = conn.points[conn.points.length - 1];
                    let labelX = last.col * moduleWidth + moduleWidth / 2;
                    let labelY = last.row * moduleHeight + moduleHeight / 2;
                    if (conn.points.length > 1) {
                        const secondLast = conn.points[conn.points.length - 2];
                        if (secondLast.col > last.col || secondLast.row < last.row) {
                            labelX = last.col * moduleWidth + moduleWidth / 4;
                            labelY = last.row * moduleHeight + 3 * moduleHeight / 4;
                        } else if (secondLast.col < last.col || secondLast.row > last.row) {
                            labelX = last.col * moduleWidth + 3 * moduleWidth / 4;
                            labelY = last.row * moduleHeight + moduleHeight / 4;
                        }
                    }
                    ctx.font = `bold ${connectionFontSize}px ${connectionFont}`;
                    ctx.fillStyle = '#000000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(conn.endName, labelX, labelY);
                }
            });

            if (currentConnection.length > 0) {
                const first = currentConnection[0];
                let labelX = first.col * moduleWidth + moduleWidth / 2;
                let labelY = first.row * moduleHeight + moduleHeight / 2;
                if (currentConnection.length > 1) {
                    const second = currentConnection[1];
                    if (second.col > first.col) {
                        labelX = first.col * moduleWidth + moduleWidth / 4;
                        labelY = first.row * moduleHeight + 3 * moduleHeight / 4;
                    } else if (second.col < first.col) {
                        labelX = first.col * moduleWidth + 3 * moduleWidth / 4;
                        labelY = first.row * moduleHeight + moduleHeight / 4;
                    } else if (second.row > first.row) {
                        labelX = first.col * moduleWidth + 3 * moduleWidth / 4;
                        labelY = first.row * moduleHeight + moduleHeight / 4;
                    } else if (second.row < first.row) {
                        labelX = first.col * moduleWidth + moduleWidth / 4;
                        labelY = first.row * moduleHeight + 3 * moduleHeight / 4;
                    }
                }
                const nextIndex = removedIndices[0] || connections.length;
                ctx.font = `bold ${connectionFontSize}px ${connectionFont}`;
                ctx.fillStyle = '#000000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${nextIndex + 1}A`, labelX, labelY);
            }
            ctx.restore();
        }
    </script>
<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><script>
        function drawMainSelection(points, color, moduleWidth, moduleHeight, isForwardSlash) {
            if (points.length < 1 || !color) return;
            const step = 20 - parseInt(document.getElementById('hatchDensity').value);
            points.forEach(point => {
                const x = point.col * moduleWidth;
                const y = point.row * moduleHeight;
                ctx.save();
                ctx.beginPath();
                ctx.rect(x, y, moduleWidth, moduleHeight);
                ctx.clip();
                ctx.strokeStyle = color + '80';
                ctx.lineWidth = 2;
                if (isForwardSlash) {
                    for (let i = -moduleHeight; i <= moduleWidth + moduleHeight; i += step) {
                        ctx.beginPath();
                        ctx.moveTo(x + i, y);
                        ctx.lineTo(x + i + moduleHeight, y + moduleHeight);
                        ctx.stroke();
                    }
                } else {
                    for (let i = -moduleHeight; i <= moduleWidth + moduleHeight; i += step) {
                        ctx.beginPath();
                        ctx.moveTo(x + i, y);
                        ctx.lineTo(x + i - moduleHeight, y + moduleHeight);
                        ctx.stroke();
                    }
                }
                ctx.restore();
            });

            if (points.length >= 2) {
                const lineWidth = Math.max(3, moduleWidth / 30);
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                points.forEach((point, index) => {
                    const px = point.col * moduleWidth + moduleWidth / 2;
                    const py = point.row * moduleHeight + moduleHeight / 2;
                    if (index === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                });
                ctx.stroke();

                const last = points[points.length - 1];
                const secondLast = points[points.length - 2];
                const x1 = secondLast.col * moduleWidth + moduleWidth / 2;
                const y1 = secondLast.row * moduleHeight + moduleHeight / 2;
                const x2 = last.col * moduleWidth + moduleWidth / 2;
                const y2 = last.row * moduleHeight + moduleHeight / 2;
                drawArrow(x1, y1, x2, y2, lineWidth);
            }
        }

        function drawArrow(x1, y1, x2, y2, lineWidth) {
            const headLength = 40;
            const dx = x2 - x1;
            const dy = y2 - y1;
            const angle = Math.atan2(dy, dx);
            const headHeight = headLength;
            const headBase = headHeight * Math.sqrt(3) / 2;

            ctx.save();
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headHeight * Math.cos(angle), y2 - headHeight * Math.sin(angle));
            ctx.lineTo(x2 - headHeight * Math.cos(angle) + headBase * Math.sin(angle) / 2, y2 - headHeight * Math.sin(angle) - headBase * Math.cos(angle) / 2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function updateLinesList() {
            linesList.innerHTML = '';
            const maxRows = Math.max(16, connections.length);
            for (let i = 0; i < maxRows; i++) {
                const div = document.createElement('div');
                div.className = 'line-item';
                const conn = connections[i];
                const isFilled = conn && conn.points.length >= 2;
                const totalCabs = isFilled ? conn.points.length : 0;
                div.innerHTML = `
                    <span style="display: inline-block; background-color: blue; padding: 2px; text-align: center;">${i + 1}</span>
                    <span>${isFilled ? `${(conn.name || '_')}/${(conn.endName || '_')} (${totalCabs} cab. total)` : '_'}</span>
                `;
                const mainInput = document.createElement('input');
                mainInput.type = 'text';
                mainInput.value = isFilled ? (conn.name || '') : '';
                mainInput.placeholder = 'main';
                mainInput.disabled = !isFilled;
                if (isFilled) {
                    mainInput.onchange = () => {
                        conn.name = mainInput.value;
                        drawGrid();
                        updateLinesList();
                        updateSummary();
                    };
                }
                div.appendChild(mainInput);

                const endInput = document.createElement('input');
                endInput.type = 'text';
                endInput.value = isFilled ? (conn.endName || '') : '';
                endInput.placeholder = 'backup';
                endInput.disabled = !isFilled;
                if (isFilled) {
                    endInput.onchange = () => {
                        conn.endName = endInput.value;
                        drawGrid();
                        updateLinesList();
                        updateSummary();
                    };
                }
                div.appendChild(endInput);

                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'вњ•';
                removeBtn.disabled = !isFilled;
                if (isFilled) {
                    removeBtn.onclick = () => removeConnection(i);
                }
                div.appendChild(removeBtn);
                linesList.appendChild(div);
            }
            updateSummary();
        }

        function handleDefaultNamesChange() {
            const checkbox = document.getElementById('useDefaultNames');
            if (!checkbox.checked) {
                connections.forEach(conn => {
                    conn.name = '';
                    conn.endName = '';
                });
                updateLinesList();
                drawGrid();
                updateSummary();
            } else {
                if (confirm("This will overwrite your Data Lines names with default ones.")) {
                    connections.forEach((conn, index) => {
                        const connectionIndex = removedIndices.includes(index) ? removedIndices.indexOf(index) : index;
                        conn.name = `${connectionIndex + 1}A`;
                        conn.endName = `${connectionIndex + 1}B`;
                    });
                    updateLinesList();
                    drawGrid();
                    updateSummary();
                } else {
                    checkbox.checked = false;
                }
            }
        }

        function updateGroupsList() {
            groupsList.innerHTML = '';
            const sortedGroups = [...selectedGroups].sort((a, b) => {
                const aMinRow = Math.min(...a.modules.map(m => m.row));
                const aMinCol = Math.min(...a.modules.filter(m => m.row === aMinRow).map(m => m.col));
                const bMinRow = Math.min(...b.modules.map(m => m.row));
                const bMinCol = Math.min(...b.modules.filter(m => m.row === bMinRow).map(m => m.col));
                return aMinRow !== bMinRow ? aMinRow - bMinRow : aMinCol - bMinCol;
            });
            sortedGroups.forEach((group, sortedIndex) => {
                group.index = sortedIndex + 1;
            });
            selectedGroups = sortedGroups;
            const maxRows = Math.max(16, selectedGroups.length);
            for (let i = 0; i < maxRows; i++) {
                const group = selectedGroups[i];
                const isFilled = group && group.modules.length > 0;
                const div = document.createElement('div');
                div.className = 'group-item';
                const numberSpan = document.createElement('span');
                numberSpan.style.cssText = 'display: inline-block; background-color: red; padding: 2px; text-align: center;';
                numberSpan.textContent = i + 1;
                div.appendChild(numberSpan);
                const modulesSpan = document.createElement('span');
                if (isFilled) {
                    const minRow = Math.min(...group.modules.map(m => m.row));
                    const maxRow = Math.max(...group.modules.map(m => m.row));
                    const minCol = Math.min(...group.modules.filter(m => m.row === minRow).map(m => m.col));
                    const maxCol = Math.max(...group.modules.filter(m => m.row === maxRow).map(m => m.col));
                    const rangeText = `${minRow + 1}.${minCol + 1}-${maxRow + 1}.${maxCol + 1}`;
                    const totalCabs = group.modules.length;
                    modulesSpan.textContent = `${rangeText} (${totalCabs} cab. total)`;
                } else {
                    modulesSpan.textContent = '_';
                }
                div.appendChild(modulesSpan);
                const colorInput = document.createElement('input');
                colorInput.type = 'number';
                colorInput.min = '1';
                colorInput.max = '25';
                colorInput.step = '1';
                colorInput.value = isFilled ? group.colorIndex : '';
                colorInput.disabled = !isFilled;
                if (isFilled) {
                    colorInput.oninput = () => {
                        const value = Math.max(1, Math.min(25, parseInt(colorInput.value)));
                        group.colorIndex = value;
                        colorInput.value = value;
                        drawGrid();
                        updateSummary();
                    };
                }
                div.appendChild(colorInput);
                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'вњ•';
                removeBtn.disabled = !isFilled;
                if (isFilled) {
                    removeBtn.onclick = () => removeGroup(i);
                }
                div.appendChild(removeBtn);
                groupsList.appendChild(div);
            }
            updateSummary();
        }

        function removeGroup(index) {
            if (!removedGroupIndices.includes(index)) {
                removedGroupIndices.push(index);
                removedGroupIndices.sort((a, b) => a - b);
            }
            selectedGroups.splice(index, 1);
            updateGroupsList();
            drawGrid();
            updateSummary();
        }

        function removeConnection(index) {
            if (!removedIndices.includes(index)) {
                removedIndices.push(index);
                removedIndices.sort((a, b) => a - b);
            }
            connections.splice(index, 1);
            renumberConnections();
            updateLinesList();
            drawGrid();
            updateSummary();
        }

        function renumberConnections() {
            lineCounter = connections.length + 1;
        }

        function isModuleInConnection(row, col) {
            return connections.some(conn => conn.points.some(p => p.row === row && p.col === col)) ||
                   currentConnection.some(p => p.row === row && p.col === col);
        }

        function removePointFromConnections(row, col) {
            const removed = [];
            connections = connections.map((conn, index) => {
                const pointIndex = conn.points.findIndex(p => p.row === row && p.col === col);
                if (pointIndex !== -1) {
                    const newPoints = conn.points.slice(0, pointIndex);
                    if (newPoints.length < 2) {
                        removed.push(index);
                        return null;
                    }
                    return { ...conn, points: newPoints };
                }
                return conn;
            }).filter(conn => conn !== null);
            removed.forEach(index => {
                if (!removedIndices.includes(index)) removedIndices.push(index);
                removedIndices.sort((a, b) => a - b);
            });
            const index = currentConnection.findIndex(p => p.row === row && p.col === col);
            if (index !== -1) {
                currentConnection = currentConnection.slice(0, index);
                if (currentConnection.length < 1) {
                    currentConnection = [];
                    currentColor = null;
                }
            }
            renumberConnections();
            updateLinesList();
            updateSummary();
        }

        function interpolatePoints(start, end) {
            const points = [];
            const steps = Math.max(Math.abs(end.row - start.row), Math.abs(end.col - start.col)) || 1;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const row = Math.round(start.row + (end.row - start.row) * t);
                const col = Math.round(start.col + (end.col - start.col) * t);
                points.push({ row, col, color: currentColor });
            }
            const uniquePoints = [];
            const seen = new Set();
            points.forEach(p => {
                const key = `${p.row},${p.col}`;
                if (!seen.has(key) && gridState[p.row][p.col]) {
                    seen.add(key);
                    uniquePoints.push(p);
                }
            });
            return uniquePoints;
        }

        function doesPathIntersectMainSelection(newPoints) {
            const { moduleWidth, moduleHeight } = getGridParams();
            const intersectingIndices = [];
            for (let i = 0; i < newPoints.length - 1; i++) {
                const p1 = {
                    x: newPoints[i].col * moduleWidth + moduleWidth / 2,
                    y: newPoints[i].row * moduleHeight + moduleHeight / 2
                };
                const p2 = {
                    x: newPoints[i + 1].col * moduleWidth + moduleWidth / 2,
                    y: newPoints[i + 1].row * moduleHeight + moduleHeight / 2
                };
                connections.forEach((conn, index) => {
                    for (let j = 0; j < conn.points.length - 1; j++) {
                        const p3 = {
                            x: conn.points[j].col * moduleWidth + moduleWidth / 2,
                            y: conn.points[j].row * moduleHeight + moduleHeight / 2
                        };
                        const p4 = {
                            x: conn.points[j + 1].col * moduleWidth + moduleWidth / 2,
                            y: conn.points[j + 1].row * moduleHeight + moduleHeight / 2
                        };
                        if (doLineSegmentsIntersect(p1, p2, p3, p4) || 
                            newPoints.some(p => conn.points.some(cp => cp.row === p.row && cp.col === p.col))) {
                            if (!intersectingIndices.includes(index)) {
                                intersectingIndices.push(index);
                            }
                        }
                    }
                });
            }
            return intersectingIndices;
        }

        function doLineSegmentsIntersect(p1, p2, p3, p4) {
            function orientation(p, q, r) {
                const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
                return val === 0 ? 0 : val > 0 ? 1 : 2;
            }
            function onSegment(p, q, r) {
                return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&
                       q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
            }
            const o1 = orientation(p1, p2, p3);
            const o2 = orientation(p1, p2, p4);
            const o3 = orientation(p3, p4, p1);
            const o4 = orientation(p3, p4, p2);
            if (o1 !== o2 && o3 !== o4) return true;
            if (o1 === 0 && onSegment(p1, p3, p2)) return true;
            if (o2 === 0 && onSegment(p1, p4, p2)) return true;
            if (o3 === 0 && onSegment(p3, p1, p4)) return true;
            if (o4 === 0 && onSegment(p3, p2, p4)) return true;
            return false;
        }

        function areModulesAdjacent(modules) {
            if (modules.length <= 1) return true;
            const visited = new Set();
            function isAdjacent(p1, p2) {
                return (Math.abs(p1.row - p2.row) === 1 && p1.col === p2.col) ||
                       (Math.abs(p1.col - p2.col) === 1 && p1.row === p2.row);
            }
            function dfs(module) {
                const key = `${module.row},${module.col}`;
                visited.add(key);
                modules.forEach(other => {
                    if (!visited.has(`${other.row},${other.col}`) && isAdjacent(module, other)) {
                        dfs(other);
                    }
                });
            }
            dfs(modules[0]);
            return visited.size === modules.length;
        }

        function findFurthestModules(modules) {
            let maxDistance = -1;
            let corner1 = modules[0];
            let corner2 = modules[0];
            for (let i = 0; i < modules.length; i++) {
                for (let j = i + 1; j < modules.length; j++) {
                    const dist = Math.abs(modules[i].row - modules[j].row) + Math.abs(modules[i].col - modules[j].col);
                    if (dist > maxDistance) {
                        maxDistance = dist;
                        corner1 = modules[i];
                        corner2 = modules[j];
                    }
                }
            }
            return [corner1, corner2];
        }

        function getModulesInRectangle(corner1, corner2, rows, cols) {
            const minRow = Math.min(corner1.row, corner2.row);
            const maxRow = Math.max(corner1.row, corner2.row);
            const minCol = Math.min(corner1.col, corner2.col);
            const maxCol = Math.max(corner1.col, corner2.col);
            const modules = [];
            for (let row = minRow; row <= maxRow; row++) {
                for (let col = minCol; col <= maxCol; col++) {
                    if (row >= 0 && row < rows && col >= 0 && col < cols && gridState[row][col]) {
                        modules.push({ row, col });
                    }
                }
            }
            return modules;
        }

        function doesGroupIntersectRectangle(group, newGroup) {
            return group.modules.some(module => 
                newGroup.some(newModule => newModule.row === module.row && newModule.col === module.col));
        }

        function getUniqueColorIndex() {
            if (removedIndices.length > 0) {
                return removedIndices.shift();
            }
            return connections.length;
        }

        function toggleModule(event) {
            const { cols, rows, moduleWidth, moduleHeight } = getGridParams();
            const rect = canvas.getBoundingClientRect();
            const scale = parseFloat(canvas.style.transform.replace('scale(', '').replace(')', '')) || 1;
            const x = (event.clientX - rect.left) / scale;
            const y = (event.clientY - rect.top) / scale;
            const col = Math.floor(x / moduleWidth);
            const row = Math.floor(y / moduleHeight);

            if (row < 0 || row >= rows || col < 0 || col >= cols) return;

            if (event.shiftKey) {
                if (gridState[row][col]) {
                    if (visibilityStart === null) {
                        visibilityStart = { row, col };
                        if (!isInLine(row, col)) {
                            gridState[row][col] = false;
                            drawGrid();
                            blinkInterval = setInterval(() => {
                                gridState[row][col] = !gridState[row][col];
                                drawGrid();
                            }, 350);
                        }
                    } else {
                        if (blinkInterval) {
                            clearInterval(blinkInterval);
                            blinkInterval = null;
                        }
                        gridState[visibilityStart.row][visibilityStart.col] = true;
                        const minRow = Math.min(visibilityStart.row, row);
                        const maxRow = Math.max(visibilityStart.row, row);
                        const minCol = Math.min(visibilityStart.col, col);
                        const maxCol = Math.max(visibilityStart.col, col);
                        for (let r = minRow; r <= maxRow; r++) {
                            for (let c = minCol; c <= maxCol; c++) {
                                if (!isInLine(r, c)) {
                                    gridState[r][c] = false;
                                }
                            }
                        }
                        visibilityStart = null;
                        drawGrid();
                        updateSummary();
                        updateScrollbars();
                    }
                }
            } else if (event.altKey) {
                if (gridState[row][col]) {
                    const module = { row, col };
                    const inModules = selectedModules.some(p => p.row === row && p.col === col);
                    const inGroup = selectedGroups.some(g => g.modules.some(p => p.row === row && p.col === col));
                    if (!inModules && !inGroup) {
                        selectedModules.push(module);
                        drawGrid();
                        updateSummary();
                        updateScrollbars();
                    }
                }
            } else if (event.ctrlKey) {
                let changesMade = false;

                const moduleIndex = selectedModules.findIndex(p => p.row === row && p.col === col);
                const inGroups = selectedGroups.some(g => g.modules.some(p => p.row === row && p.col === col));
                if (moduleIndex !== -1 || inGroups) {
                    if (moduleIndex !== -1) {
                        selectedModules.splice(moduleIndex, 1);
                        changesMade = true;
                    }
                    const originalGroupCount = selectedGroups.length;
                    selectedGroups = selectedGroups.map(group => ({
                        ...group,
                        modules: group.modules.filter(p => p.row !== row || p.col !== col)
                    })).filter(g => g.modules.length > 0);
                    if (selectedGroups.length !== originalGroupCount || selectedGroups.some(g => g.modules.length !== originalGroupCount)) {
                        updateGroupsList();
                        changesMade = true;
                    }
                } else {
                    const inConnections = isModuleInConnection(row, col);
                    if (inConnections) {
                        removePointFromConnections(row, col);
                        changesMade = true;
                    } else {
                        if (gridState[row][col] !== undefined) {
                            gridState[row][col] = !gridState[row][col];
                            changesMade = true;
                        }
                    }
                }

                if (changesMade) {
                    drawGrid();
                    updateSummary();
                    updateScrollbars();
                }
            } else {
                const point = { row, col, color: currentColor };
                if (!isModuleInConnection(row, col) && !currentConnection.some(p => p.row === row && p.col === col)) {
                    if (currentConnection.length === 0) {
                        const colorIndex = getUniqueColorIndex();
                        currentConnection = [point];
                        currentColor = mainColors[colorIndex % mainColors.length];
                        drawGrid();
                        updateSummary();
                        updateScrollbars();
                    } else {
                        const lastPoint = currentConnection[currentConnection.length - 1];
                        const newPoints = interpolatePoints(lastPoint, point);
                        if (newPoints.length > 0) {
                            const intersectingIndices = doesPathIntersectMainSelection(newPoints);
                            if (intersectingIndices.length > 0) {
                                intersectingIndices.sort((a, b) => b - a);
                                intersectingIndices.forEach(index => {
                                    if (!removedIndices.includes(index)) removedIndices.push(index);
                                    connections.splice(index, 1);
                                });
                                removedIndices.sort((a, b) => a - b);
                                renumberConnections();
                                updateLinesList();
                                updateSummary();
                                updateScrollbars();
                            }
                            newPoints.forEach(p => {
                                if (!currentConnection.some(cp => cp.row === p.row && cp.col === p.col)) {
                                    currentConnection.push({ ...p, color: currentColor });
                                }
                            });
                            drawGrid();
                            updateSummary();
                            updateScrollbars();
                        }
                    }
                }
            }
        }

        function handleDoubleClick(event) {
            const { cols, rows, moduleWidth, moduleHeight } = getGridParams();
            const rect = canvas.getBoundingClientRect();
            const scale = parseFloat(canvas.style.transform.replace('scale(', '').replace(')', '')) || 1;
            const x = (event.clientX - rect.left) / scale;
            const y = (event.clientY - rect.top) / scale;
            const col = Math.floor(x / moduleWidth);
            const row = Math.floor(y / moduleHeight);

            if (row < 0 || row >= rows || col < 0 || col >= cols || !gridState[row][col]) return;

            if (event.altKey && selectedModules.length > 0) {
                selectedGroups = selectedGroups.map(group => ({
                    ...group,
                    modules: group.modules.filter(p => !selectedModules.some(m => m.row === p.row && m.col === p.col))
                })).filter(g => g.modules.length > 0);
                let newGroup;
                if (areModulesAdjacent(selectedModules)) {
                    newGroup = selectedModules;
                } else {
                    const [corner1, corner2] = findFurthestModules(selectedModules);
                    newGroup = getModulesInRectangle(corner1, corner2, rows, cols);
                }
                selectedGroups = selectedGroups.filter(group => !doesGroupIntersectRectangle(group, newGroup));
                const groupIndex = removedGroupIndices.length > 0 ? removedGroupIndices.shift() : groupCounter++;
                const colorIndex = (groupIndex - 1) % 3 + 4;
                selectedGroups.push({ index: groupIndex, modules: [...newGroup], colorIndex });
                selectedModules = [];
                updateGroupsList();
                drawGrid();
                updateSummary();
                updateScrollbars();
            } else if (currentConnection.length >= 1) {
                if (currentConnection.some(p => p.row === row && p.col === col)) {
                    completeCurrentConnection();
                    drawGrid();
                    updateSummary();
                    updateScrollbars();
                }
            }
        }

        function completeCurrentConnection() {
            if (currentConnection.length < 2 || !currentColor) {
                currentConnection = [];
                currentColor = null;
                return;
            }
            const intersectingIndices = doesPathIntersectMainSelection(currentConnection);
            if (intersectingIndices.length > 0) {
                intersectingIndices.sort((a, b) => b - a);
                intersectingIndices.forEach(index => {
                    if (!removedIndices.includes(index)) removedIndices.push(index);
                    connections.splice(index, 1);
                });
                removedIndices.sort((a, b) => a - b);
                renumberConnections();
                updateLinesList();
                updateSummary();
                updateScrollbars();
            }
            const connectionIndex = getUniqueColorIndex();
            const useDefaultNames = document.getElementById('useDefaultNames').checked;
            connections.push({
                points: [...currentConnection],
                color: mainColors[connectionIndex % mainColors.length],
                name: useDefaultNames ? `${connectionIndex + 1}A` : '',
                endName: useDefaultNames ? `${connectionIndex + 1}B` : ''
            });
            lineCounter = Math.max(lineCounter, connections.length + 1);
            currentConnection = [];
            currentColor = null;
            renumberConnections();
            updateLinesList();
            drawGrid();
            updateSummary();
            updateScrollbars();
        }

        function exportToPNG() {
            const { cols, rows } = getGridParams();
            const link = document.createElement('a');
            link.download = `grid_${cols}x${rows}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function exportToXML() {
            const { cols, rows, moduleWidth, moduleHeight } = getGridParams();
            const moduleSize = document.getElementById('moduleSize').value;
            const xml = new XMLSerializer().serializeToString(createXML());
            const blob = new Blob([xml], { type: 'application/xml' });
            const link = document.createElement('a');
            link.download = `grid_settings_${cols}x${rows}.xml`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        function createXML() {
            const xml = new DOMParser().parseFromString('<grid></grid>', 'application/xml');
            const root = xml.documentElement;
            const params = xml.createElement('params');
            params.setAttribute('cols', document.getElementById('cols').value);
            params.setAttribute('rows', document.getElementById('rows').value);
            params.setAttribute('moduleSize', document.getElementById('moduleSize').value);
            if (document.getElementById('moduleSize').value === 'custom') {
                params.setAttribute('moduleWidth', document.getElementById('moduleWidth').value);
                params.setAttribute('moduleHeight', document.getElementById('moduleHeight').value);
            } else {
                params.setAttribute('lastPresetSize', lastPresetSize);
            }
            params.setAttribute('connectionFont', document.getElementById('connectionFont').value);
            params.setAttribute('connectionFontSize', document.getElementById('connectionFontSize').value);
            root.appendChild(params);

            const gridStateElem = xml.createElement('gridState');
            gridState.forEach((row, r) => {
                row.forEach((visible, c) => {
                    const module = xml.createElement('module');
                    module.setAttribute('row', r);
                    module.setAttribute('col', c);
                    module.setAttribute('visible', visible);
                    gridStateElem.appendChild(module);
                });
            });
            root.appendChild(gridStateElem);

            const mainSelections = xml.createElement('mainSelections');
            connections.forEach(conn => {
                const selection = xml.createElement('selection');
                selection.setAttribute('color', conn.color);
                selection.setAttribute('name', conn.name);
                selection.setAttribute('endName', conn.endName);
                conn.points.forEach(point => {
                    const p = xml.createElement('point');
                    p.setAttribute('row', point.row);
                    p.setAttribute('col', point.col);
                    selection.appendChild(p);
                });
                mainSelections.appendChild(selection);
            });
            root.appendChild(mainSelections);

            const altGroups = xml.createElement('altGroups');
            const sortedGroups = [...selectedGroups].sort((a, b) => {
                const aMinRow = Math.min(...a.modules.map(m => m.row));
                const aMinCol = Math.min(...a.modules.filter(m => m.row === aMinRow).map(m => m.col));
                const bMinRow = Math.min(...b.modules.map(m => m.row));
                const bMinCol = Math.min(...b.modules.filter(m => m.row === bMinRow).map(m => m.col));
                return aMinRow !== bMinRow ? aMinRow - bMinRow : aMinCol - bMinCol;
            });
            sortedGroups.forEach((group, index) => {
                const g = xml.createElement('group');
                g.setAttribute('index', index + 1);
                g.setAttribute('colorIndex', group.colorIndex);
                group.modules.forEach(module => {
                    const m = xml.createElement('module');
                    m.setAttribute('row', module.row);
                    m.setAttribute('col', module.col);
                    g.appendChild(m);
                });
                altGroups.appendChild(g);
            });
            root.appendChild(altGroups);

            return xml;
        }

        function importFromXML(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const xml = new DOMParser().parseFromString(e.target.result, 'application/xml');
                const parseError = xml.getElementsByTagName('parsererror')[0];
                if (parseError) {
                    alert('Invalid XML file');
                    console.error('Invalid XML file', parseError);
                    return;
                }

                const params = xml.getElementsByTagName('params')[0];
                if (!params) {
                    alert('Missing params in XML');
                    return;
                }

                const newCols = parseInt(params.getAttribute('cols'));
                const newRows = parseInt(params.getAttribute('rows'));
                const moduleSize = params.getAttribute('moduleSize') || '104';
                const connectionFont = params.getAttribute('connectionFont') || 'Merriweather, serif';
                const connectionFontSize = parseInt(params.getAttribute('connectionFontSize')) || 21;
                let newModuleWidth, newModuleHeight;

                if (moduleSize === 'custom') {
                    newModuleWidth = parseInt(params.getAttribute('moduleWidth')) || 104;
                    newModuleHeight = parseInt(params.getAttribute('moduleHeight')) || 104;
                } else {
                    newModuleWidth = newModuleHeight = parseInt(moduleSize) || 104;
                    lastPresetSize = parseInt(params.getAttribute('lastPresetSize')) || parseInt(moduleSize) || 104;
                }

                document.getElementById('cols').value = newCols;
                document.getElementById('rows').value = newRows;
                document.getElementById('moduleSize').value = moduleSize;
                document.getElementById('connectionFont').value = connectionFont;
                document.getElementById('connectionFontSize').value = connectionFontSize;
                const customSizeInputs = document.getElementById('customSizeInputs');
                const moduleWidthInput = document.getElementById('moduleWidth');
                const moduleHeightInput = document.getElementById('moduleHeight');
                if (moduleSize === 'custom') {
                    customSizeInputs.style.display = 'flex';
                    moduleWidthInput.value = newModuleWidth;
                    moduleHeightInput.value = newModuleHeight;
                } else {
                    customSizeInputs.style.display = 'none';
                    moduleWidthInput.value = lastPresetSize;
                    moduleHeightInput.value = lastPresetSize;
                }

                gridState = Array(newRows).fill().map(() => Array(newCols).fill(true));
                connections = [];
                currentConnection = [];
                currentColor = null;
                selectedModules = [];
                selectedGroups = [];
                lineCounter = 1;
                groupCounter = 1;
                removedIndices = [];
                removedGroupIndices = [];

                canvas.width = newCols * newModuleWidth;
                canvas.height = newRows * newModuleHeight;

                const gridStateElem = xml.getElementsByTagName('gridState')[0];
                if (gridStateElem) {
                    const modules = gridStateElem.getElementsByTagName('module');
                    for (let m of modules) {
                        const r = parseInt(m.getAttribute('row'));
                        const c = parseInt(m.getAttribute('col'));
                        const visible = m.getAttribute('visible') === 'true';
                        if (r >= 0 && r < newRows && c >= 0 && c < newCols) {
                            gridState[r][c] = visible;
                        }
                    }
                }

                const mainSelections = xml.getElementsByTagName('mainSelections')[0];
                if (mainSelections) {
                    const selections = mainSelections.getElementsByTagName('selection');
                    for (let s of selections) {
                        const points = [];
                        const ps = s.getElementsByTagName('point');
                        for (let p of ps) {
                            points.push({
                                row: parseInt(p.getAttribute('row')),
                                col: parseInt(p.getAttribute('col'))
                            });
                        }
                        if (points.length > 0) {
                            connections.push({
                                points,
                                color: s.getAttribute('color') || mainColors[connections.length % mainColors.length],
                                name: s.getAttribute('name') || '',
                                endName: s.getAttribute('endName') || ''
                            });
                        }
                    }
                    lineCounter = connections.length + 1;
                }

                const altGroups = xml.getElementsByTagName('altGroups')[0];
                if (altGroups) {
                    const groups = Array.from(altGroups.getElementsByTagName('group'));
                    const sortedGroups = groups.map(g => {
                        const modules = Array.from(g.getElementsByTagName('module')).map(m => ({
                            row: parseInt(m.getAttribute('row')),
                            col: parseInt(m.getAttribute('col'))
                        }));
                        return {
                            index: parseInt(g.getAttribute('index')) || 1,
                            colorIndex: parseInt(g.getAttribute('colorIndex')) || 1,
                            modules
                        };
                    }).sort((a, b) => {
                        const aMinRow = Math.min(...a.modules.map(m => m.row));
                        const aMinCol = Math.min(...a.modules.filter(m => m.row === aMinRow).map(m => m.col));
                        const bMinRow = Math.min(...b.modules.map(m => m.row));
                        const bMinCol = Math.min(...b.modules.filter(m => m.row === bMinRow).map(m => m.col));
                        return aMinRow !== bMinRow ? aMinRow - bMinRow : aMinCol - bMinCol;
                    });

                    selectedGroups = sortedGroups.map((g, idx) => ({
                        index: idx + 1,
                        colorIndex: g.colorIndex,
                        modules: g.modules
                    }));
                    groupCounter = selectedGroups.length + 1;
                }

                updateLinesList();
                updateGroupsList();
                drawGrid();
                updateSummary();
                updateScrollbars();
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        document.getElementById('moduleColor').addEventListener('change', () => { drawGrid(); updateSummary(); });
        document.getElementById('moduleLabelFontSize').addEventListener('input', () => { drawGrid(); updateSummary(); });
        document.getElementById('moduleLabelColor').addEventListener('change', () => { drawGrid(); updateSummary(); });
        document.getElementById('hatchDensity').addEventListener('input', () => { drawGrid(); updateSummary(); });
        document.getElementById('moduleWidth').addEventListener('input', generateGrid);
        document.getElementById('moduleHeight').addEventListener('input', generateGrid);
        canvas.addEventListener('click', toggleModule);
        canvas.addEventListener('dblclick', handleDoubleClick);
        window.addEventListener('resize', updateScrollbars);
        generateGrid();

        function isInLine(row, col) {
            return isModuleInConnection(row, col) || selectedGroups.some(g => g.modules.some(m => m.row === row && m.col === col));
        }

        function exportToSVG() {
            const { cols, rows, moduleWidth, moduleHeight, moduleColor, moduleLabelColor } = getGridParams();
            const labelFontSize = parseInt(document.getElementById('moduleLabelFontSize').value);
            const connectionFontSize = parseInt(document.getElementById('connectionFontSize').value);
            const hatchDensity = parseInt(document.getElementById('hatchDensity').value);
            const step = 20 - hatchDensity;

            let svgContent = `<svg width="${cols * moduleWidth}" height="${rows * moduleHeight}" xmlns="http://www.w3.org/2000/svg">`;

            let defs = '<defs>';
            connections.forEach((conn, index) => {
                const color80 = conn.color + '80';
                const isForwardSlash = index % 2 === 0;
                defs += `
                    <pattern id="pattern${index}" width="${step}" height="${step}" patternUnits="userSpaceOnUse" patternTransform="rotate(${isForwardSlash ? '45' : '-45'})">
                        <line x1="0" y1="0" x2="0" y2="${step}" stroke="${color80}" stroke-width="2"/>
                    </pattern>
                `;
            });
            defs += '</defs>';
            svgContent += defs;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (gridState[row][col]) {
                        const x = col * moduleWidth;
                        const y = row * moduleHeight;
                        svgContent += `<rect x="${x}" y="${y}" width="${moduleWidth}" height="${moduleHeight}" fill="${moduleColor}" stroke="${moduleLabelColor}" stroke-width="1"/>`;
                        svgContent += `<text x="${x + 10}" y="${y + labelFontSize + 10}" font-family="Arial, sans-serif" font-size="${labelFontSize}px" fill="${moduleLabelColor}">${row + 1}.${col + 1}</text>`;
                    }
                }
            }

            connections.forEach((conn, index) => {
                conn.points.forEach(point => {
                    const x = point.col * moduleWidth;
                    const y = point.row * moduleHeight;
                    svgContent += `<rect x="${x}" y="${y}" width="${moduleWidth}" height="${moduleHeight}" fill="url(#pattern${index})"/>`;
                });
                if (conn.points.length >= 2) {
                    let path = '';
                    conn.points.forEach(point => {
                        const px = point.col * moduleWidth + moduleWidth / 2;
                        const py = point.row * moduleHeight + moduleHeight / 2;
                        path += (path ? ' L' : 'M') + `${px} ${py}`;
                    });
                    svgContent += `<path d="${path}" fill="none" stroke="#000000" stroke-width="${Math.max(3, moduleWidth / 30)}"/>`;

                    const last = conn.points[conn.points.length - 1];
                    const secondLast = conn.points[conn.points.length - 2];
                    const x1 = secondLast.col * moduleWidth + moduleWidth / 2;
                    const y1 = secondLast.row * moduleHeight + moduleHeight / 2;
                    const x2 = last.col * moduleWidth + moduleWidth / 2;
                    const y2 = last.row * moduleHeight + moduleHeight / 2;
                    const angle = Math.atan2(y2 - y1, x2 - x1);
                    const headLength = 40;
                    const headHeight = headLength;
                    const headBase = headHeight * Math.sqrt(3) / 2;
                    svgContent += `<polygon points="${x2},${y2} ${x2 - headHeight * Math.cos(angle)},${y2 - headHeight * Math.sin(angle)} ${x2 - headHeight * Math.cos(angle) + headBase * Math.sin(angle) / 2},${y2 - headHeight * Math.sin(angle) - headBase * Math.cos(angle) / 2}" fill="#000000"/>`;
                }

                if (conn.name) {
                    const first = conn.points[0];
                    let labelX = first.col * moduleWidth + moduleWidth / 4;
                    let labelY = first.row * moduleHeight + 3 * moduleHeight / 4;
                    if (conn.points.length > 1) {
                        const second = conn.points[1];
                        if (second.col > first.col) {
                            labelX = first.col * moduleWidth + moduleWidth / 4;
                            labelY = first.row * moduleHeight + 3 * moduleHeight / 4;
                        } else if (second.col < first.col) {
                            labelX = first.col * moduleWidth + 3 * moduleWidth / 4;
                            labelY = first.row * moduleHeight + moduleHeight / 4;
                        } else if (second.row > first.row) {
                            labelX = first.col * moduleWidth + 3 * moduleWidth / 4;
                            labelY = first.row * moduleHeight + moduleHeight / 4;
                        } else if (second.row < first.row) {
                            labelX = first.col * moduleWidth + moduleWidth / 4;
                            labelY = first.row * moduleHeight + 3 * moduleHeight / 4;
                        }
                    }
                    svgContent += `<text x="${labelX}" y="${labelY}" font-family="Micro 5" font-size="${connectionFontSize}px" font-weight="bold" text-anchor="middle">${conn.name}</text>`;
                }
                if (conn.endName) {
                    const last = conn.points[conn.points.length - 1];
                    let labelX = last.col * moduleWidth + moduleWidth / 4;
                    let labelY = last.row * moduleHeight + 3 * moduleHeight / 4;
                    if (conn.points.length > 1) {
                        const secondLast = conn.points[conn.points.length - 2];
                        if (secondLast.col > last.col || secondLast.row < last.row) {
                            labelX = last.col * moduleWidth + moduleWidth / 4;
                            labelY = last.row * moduleHeight + 3 * moduleHeight / 4;
                        } else if (secondLast.col < last.col || secondLast.row > last.row) {
                            labelX = last.col * moduleWidth + 3 * moduleWidth / 4;
                            labelY = last.row * moduleHeight + moduleHeight / 4;
                        }
                    }
                    svgContent += `<text x="${labelX}" y="${labelY}" font-family="Micro 5" font-size="${connectionFontSize}px" font-weight="bold" text-anchor="middle">${conn.endName}</text>`;
                }
            });

            selectedGroups.forEach((group, index) => {
                if (group.modules.length > 0) {
                    const edges = [];
                    const offset = 4.5;
                    group.modules.forEach(module => {
                        const x = module.col * moduleWidth;
                        const y = module.row * moduleHeight;
                        if (!group.modules.some(p => p.row === module.row - 1 && p.col === module.col)) {
                            edges.push(`M${x + offset},${y + offset} L${x + moduleWidth - offset},${y + offset}`);
                        }
                        if (!group.modules.some(p => p.row === module.row + 1 && p.col === module.col)) {
                            edges.push(`M${x + offset},${y + moduleHeight - offset} L${x + moduleWidth - offset},${y + moduleHeight - offset}`);
                        }
                        if (!group.modules.some(p => p.row === module.row && p.col === module.col - 1)) {
                            edges.push(`M${x + offset},${y + offset} L${x + offset},${y + moduleHeight - offset}`);
                        }
                        if (!group.modules.some(p => p.row === module.row && p.col === module.col + 1)) {
                            edges.push(`M${x + moduleWidth - offset},${y + offset} L${x + moduleWidth - offset},${y + moduleHeight - offset}`);
                        }
                    });
                    const path = edges.join(' ');
                    svgContent += `<path d="${path}" fill="none" stroke="${groupColors[group.colorIndex - 1]}" stroke-width="9" stroke-dasharray="22.5,10"/>`;
                }
            });

            if (currentConnection.length > 0) {
                const index = connections.length;
                const isForwardSlash = (removedIndices[0] || index) % 2 === 0;
                currentConnection.forEach(point => {
                    const x = point.col * moduleWidth;
                    const y = point.row * moduleHeight;
                    svgContent += `<rect x="${x}" y="${y}" width="${moduleWidth}" height="${moduleHeight}" fill="url(#pattern${index})"/>`;
                });
                if (currentConnection.length >= 2) {
                    let path = '';
                    currentConnection.forEach(point => {
                        const px = point.col * moduleWidth + moduleWidth / 2;
                        const py = point.row * moduleHeight + moduleHeight / 2;
                        path += (path ? ' L' : 'M') + `${px} ${py}`;
                    });
                    svgContent += `<path d="${path}" fill="none" stroke="#000000" stroke-width="${Math.max(3, moduleWidth / 30)}"/>`;

                    const last = currentConnection[currentConnection.length - 1];
                    const secondLast = currentConnection[currentConnection.length - 2];
                    const x1 = secondLast.col * moduleWidth + moduleWidth / 2;
                    const y1 = secondLast.row * moduleHeight + moduleHeight / 2;
                    const x2 = last.col * moduleWidth + moduleWidth / 2;
                    const y2 = last.row * moduleHeight + moduleHeight / 2;
                    const angle = Math.atan2(y2 - y1, x2 - x1);
                    const headLength = 40;
                    const headHeight = headLength;
                    const headBase = headHeight * Math.sqrt(3) / 2;
                    svgContent += `<polygon points="${x2},${y2} ${x2 - headHeight * Math.cos(angle)},${y2 - headHeight * Math.sin(angle)} ${x2 - headHeight * Math.cos(angle) + headBase * Math.sin(angle) / 2},${y2 - headHeight * Math.sin(angle) - headBase * Math.cos(angle) / 2}" fill="#000000"/>`;
                }

                const first = currentConnection[0];
                let labelX = first.col * moduleWidth + moduleWidth / 4;
                let labelY = first.row * moduleHeight + 3 * moduleHeight / 4;
                if (currentConnection.length > 1) {
                    const second = currentConnection[1];
                    if (second.col > first.col) {
                        labelX = first.col * moduleWidth + moduleWidth / 4;
                        labelY = first.row * moduleHeight + 3 * moduleHeight / 4;
                    } else if (second.col < first.col) {
                        labelX = first.col * moduleWidth + 3 * moduleWidth / 4;
                        labelY = first.row * moduleHeight + moduleHeight / 4;
                    } else if (second.row > first.row) {
                        labelX = first.col * moduleWidth + 3 * moduleWidth / 4;
                        labelY = first.row * moduleHeight + moduleHeight / 4;
                    } else if (second.row < first.row) {
                        labelX = first.col * moduleWidth + moduleWidth / 4;
                        labelY = first.row * moduleHeight + 3 * moduleHeight / 4;
                    }
                }
                const nextIndex = removedIndices[0] || connections.length;
                svgContent += `<text x="${labelX}" y="${labelY}" font-family="Micro 5" font-size="${connectionFontSize}px" font-weight="bold" text-anchor="middle">${nextIndex + 1}A</text>`;
            }

            svgContent += `</svg>`;

            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = `grid_${cols}x${rows}.svg`;
            link.href = url;
            link.click();
        }
    </script>
</body>
</html>
